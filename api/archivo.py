from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    MessageHandler,
    filters
)
from db import conectar_db
from telegram.helpers import escape_markdown

# ------------------ Configuraci√≥n ---------------------
ADMIN_IDS = [2047892910]
TOKEN = '8154074350:AAE3KUzGqHN6xEt7mtEq1fIakFxgM-Jelzs'

# ------------------ Funci√≥n de ayuda para Admin ---------------------
def es_admin(user_id):
    return user_id in ADMIN_IDS
# Cerca del inicio del c√≥digo, despu√©s de la funci√≥n start
async def mostrar_menu_principal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Genera y muestra el men√∫ principal con los botones de inicio."""
    botones_inicio = [
        [InlineKeyboardButton("Recargar üì≤", callback_data="recargar")],
        [InlineKeyboardButton("Historial üìú", callback_data="historial")]
    ]
    reply_markup = InlineKeyboardMarkup(botones_inicio)
    texto = "¬°Bienvenido! Soy tu bot de recargas.\n¬øQu√© deseas hacer?"

    # Diferenciamos si es un comando nuevo o una edici√≥n de un mensaje existente
    if update.callback_query:
        # Si viene de un bot√≥n (callback), editamos el mensaje
        await update.callback_query.edit_message_text(text=texto, reply_markup=reply_markup)
    else:
        # Si viene de un comando (como /start), enviamos un nuevo mensaje
        await update.message.reply_text(text=texto, reply_markup=reply_markup)
# ------------------ Comando /start ---------------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja el comando /start. Registra al usuario y muestra el men√∫."""
    user = update.effective_user
    telegram_id = user.id
    nombre = user.full_name
    username = user.username or "N/A"

    try:
        conn = conectar_db()
        with conn.cursor() as cur:
            cur.execute("""
                INSERT INTO usuarios (telegram_id, nombre, username)
                VALUES (%s, %s, %s)
                ON CONFLICT (telegram_id) DO UPDATE SET
                    nombre = EXCLUDED.nombre,
                    username = EXCLUDED.username;
            """, (telegram_id, nombre, username))
            conn.commit()
    except Exception as e:
        print(f"Error al guardar usuario {telegram_id}: {e}")
    finally:
        if 'conn' in locals() and conn: conn.close()
    
    # Llamamos a la nueva funci√≥n para mostrar el men√∫
    await mostrar_menu_principal(update, context)
# ------------------ Manejador de todos los Botones (Callbacks) ---------------------
async def manejar_callback_unificado(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    data = query.data

    # --- L√ìGICA PARA USUARIOS NORMALES ---
    if data == "recargar":
        botones_ofertas = [
            [InlineKeyboardButton("120 saldo x 250 CUP", callback_data="oferta_1")],
            [InlineKeyboardButton("240 saldo x 500 CUP", callback_data="oferta_2")],
            [InlineKeyboardButton("360 saldo x 800 CUP", callback_data="oferta_3")]
        ]
        await query.edit_message_text(text="üì¶ Ofertas disponibles:\nSelecciona una opci√≥n:", reply_markup=InlineKeyboardMarkup(botones_ofertas))

    elif data.startswith("oferta_"):
        oferta_id = int(data.split("_")[1])
        try:
            conn = conectar_db()
            with conn.cursor() as cur:
                cur.execute("SELECT descripcion FROM ofertas WHERE id = %s;", (oferta_id,))
                oferta_info = cur.fetchone()
            if not oferta_info:
                await query.edit_message_text("‚ùå Error: Esa oferta ya no existe.")
                return
            
            oferta_txt = oferta_info[0]
            context.user_data["estado"] = "esperando_numero"
            context.user_data["oferta_id"] = oferta_id
            context.user_data["oferta_txt"] = oferta_txt
            await query.edit_message_text(f"‚úÖ Has seleccionado: {oferta_txt}.\n\nüì± Ahora, por favor, escribe el n√∫mero de tel√©fono que deseas recargar:")
        except Exception as e:
            print(f"Error al buscar oferta {oferta_id}: {e}")
            await query.edit_message_text("‚ùå Ocurri√≥ un error.")
        finally:
            if 'conn' in locals() and conn: conn.close()

    elif data == "historial":
        try:
            conn = conectar_db()
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT p.fecha_solicitud, o.descripcion, p.numero_destino, p.estado
                    FROM pedidos p
                    JOIN ofertas o ON p.oferta_id = o.id
                    WHERE p.usuario_id = %s
                    ORDER BY p.fecha_solicitud DESC
                    LIMIT 5;
                """, (user_id,))
                historial = cur.fetchall()

            if not historial:
                mensaje = "A√∫n no has realizado ninguna recarga. ¬°An√≠mate a hacer la primera! üòä"
                botones = [[InlineKeyboardButton("‚¨ÖÔ∏è Volver", callback_data="menu_principal")]]
                await query.edit_message_text(text=mensaje, reply_markup=InlineKeyboardMarkup(botones))
                return

            # Diccionario para mapear estados a emojis y texto
            status_map = {
                "confirmado": "‚úÖ Confirmado",
                "pendiente": "‚è≥ Pendiente",
                "rechazado": "‚ùå Rechazado"
            }

            # Construimos el mensaje del historial
            partes_mensaje = ["üìú *Tu historial de recargas recientes:*\n"]
            for fecha, oferta, numero, estado in historial:
                fecha_formateada = fecha.strftime('%d/%m/%Y %H:%M')
                status_texto = status_map.get(estado, f"‚ùì {estado.capitalize()}")
                linea = (
                    f"üóìÔ∏è *{fecha_formateada}*\n"
                    f"   - *Oferta:* {oferta}\n"
                    f"   - *N√∫mero:* `{numero}`\n"
                    f"   - *Estado:* {status_texto}\n"
                )
                partes_mensaje.append(linea)

            mensaje_final = "\n".join(partes_mensaje)
            botones = [[InlineKeyboardButton("‚¨ÖÔ∏è Volver al men√∫", callback_data="menu_principal")]]
            await query.edit_message_text(
                text=mensaje_final,
                reply_markup=InlineKeyboardMarkup(botones),
                parse_mode="Markdown"
            )

        except Exception as e:
            print(f"Error al obtener historial para {user_id}: {e}")
            await query.edit_message_text("‚ùå Ocurri√≥ un error al cargar tu historial.")
        finally:
            if 'conn' in locals() and conn: conn.close()

    # A√±ade este nuevo elif para manejar el bot√≥n "Volver"
    elif data == "menu_principal":
        await mostrar_menu_principal(update, context)


    # --- L√ìGICA PARA ADMINISTRADORES ---
    if es_admin(user_id):
        if data == "admin_pedidos":
            try:
                conn = conectar_db()
                with conn.cursor() as cur:
                    cur.execute("SELECT p.id, u.nombre, o.descripcion FROM pedidos p JOIN usuarios u ON p.usuario_id = u.telegram_id JOIN ofertas o ON p.oferta_id = o.id WHERE p.estado = 'pendiente' ORDER BY p.fecha_solicitud ASC LIMIT 10;")
                    pedidos = cur.fetchall()
                if not pedidos:
                    await query.edit_message_text("‚úÖ No hay pedidos pendientes.")
                    return
                botones = [[InlineKeyboardButton(f"#{pid} - {nombre} ({oferta})", callback_data=f"ver_pedido_{pid}")] for pid, nombre, oferta in pedidos]
                botones.append([InlineKeyboardButton("‚¨ÖÔ∏è Volver al men√∫ admin", callback_data="admin_menu")])
                await query.edit_message_text("üìã Pedidos pendientes:", reply_markup=InlineKeyboardMarkup(botones))
            except Exception as e:
                print(f"Error en admin_pedidos: {e}")
                await query.edit_message_text("‚ùå Error al cargar los pedidos.")
            finally:
                if 'conn' in locals() and conn:
                    conn.close()

        elif data.startswith("ver_pedido_"):
            pedido_id = int(data.split("_")[-1])
            try:
                conn = conectar_db()
                with conn.cursor() as cur:
                    cur.execute("SELECT p.id, u.nombre, u.username, p.numero_destino, o.descripcion, c.tipo, c.contenido FROM pedidos p JOIN usuarios u ON p.usuario_id = u.telegram_id JOIN ofertas o ON p.oferta_id = o.id LEFT JOIN comprobantes c ON c.pedido_id = p.id WHERE p.id = %s;", (pedido_id,))
                    pedido_info = cur.fetchone()
                if not pedido_info:
                    await query.edit_message_text("‚ùå Pedido no encontrado.")
                    return
                
                pid, nombre, username, numero, oferta, comp_tipo, comp_contenido = pedido_info
                
                nombre_escaped = escape_markdown(nombre or "Sin Nombre", version=2)
                username_escaped = escape_markdown(username or "N/A", version=2)
                oferta_escaped = escape_markdown(oferta or "Sin Descripci√≥n", version=2)
                numero_escaped = escape_markdown(numero or "Sin N√∫mero", version=2)
                
                # --- CORRECCI√ìN FINAL EN LA L√çNEA SIGUIENTE ---
                mensaje = (
                    f"üì¶ *Detalle del Pedido \\#{pid}*\n\n"
                    f"üë§ *Cliente:* {nombre_escaped} \\(@{username_escaped}\\)\n"  # Se escapan '(' y ')'
                    f"üì± *N√∫mero a Recargar:* `{numero_escaped}`\n"
                    f"üéÅ *Oferta Solicitada:* {oferta_escaped}\n\n"
                    f"üßæ *Comprobante Adjunto:*"
                )
                # -------------------------------------------------

                await query.edit_message_text(mensaje, parse_mode="MarkdownV2")
                
                if comp_tipo == 'imagen':
                    await context.bot.send_photo(chat_id=user_id, photo=comp_contenido, caption="Comprobante de imagen:")
                elif comp_tipo == 'texto':
                    comp_contenido_escaped = escape_markdown(comp_contenido or "", version=2)
                    await context.bot.send_message(chat_id=user_id, text=f"Comprobante de texto:\n\n`{comp_contenido_escaped}`", parse_mode="MarkdownV2")
                else:
                    await context.bot.send_message(chat_id=user_id, text="‚ö†Ô∏è No se encontr√≥ comprobante para este pedido.")

                botones_accion = [
                    [InlineKeyboardButton("‚úÖ Confirmar", callback_data=f"confirmar_{pid}"), InlineKeyboardButton("‚ùå Rechazar", callback_data=f"rechazar_{pid}")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Volver a la lista", callback_data="admin_pedidos")]
                ]
                await context.bot.send_message(chat_id=user_id, text="üëá ¬øQu√© deseas hacer?", reply_markup=InlineKeyboardMarkup(botones_accion))
            except Exception as e:
                print(f"Error en ver_pedido: {e}")
                await query.edit_message_text("‚ùå Error al cargar detalles.")
            finally:
                if 'conn' in locals() and conn:
                    conn.close()
        elif data.startswith("confirmar_"):
            pedido_id = int(data.split("_")[1])
            try:
                conn = conectar_db()
                with conn.cursor() as cur:
                    cur.execute("UPDATE pedidos SET estado = 'confirmado', fecha_confirmacion = CURRENT_TIMESTAMP WHERE id = %s RETURNING usuario_id;", (pedido_id,))
                    resultado = cur.fetchone()
                    conn.commit()
                if resultado:
                    await context.bot.send_message(chat_id=resultado[0], text=f"üéâ ¬°Tu pedido #{pedido_id} ha sido confirmado!")
                await query.edit_message_text(f"‚úÖ Pedido #{pedido_id} confirmado y usuario notificado.")
            except Exception as e:
                print(f"Error al confirmar pedido {pedido_id}: {e}")
            finally:
                if 'conn' in locals() and conn: conn.close()

        elif data.startswith("rechazar_"):
            pedido_id = int(data.split("_")[1])
            context.user_data["estado_admin"] = "esperando_motivo_rechazo"
            context.user_data["pedido_a_rechazar_id"] = pedido_id
            await query.edit_message_text("‚úèÔ∏è Escribe el motivo del rechazo. Se le enviar√° al usuario.")
        
        elif data == "admin_menu":
             await admin(update, context, is_callback=True)

# ------------------ Manejador de mensajes de texto ---------------------
async def recibir_mensaje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    mensaje = update.message.text
    
    if es_admin(user_id) and context.user_data.get("estado_admin") == "esperando_motivo_rechazo":
        pedido_id = context.user_data.get("pedido_a_rechazar_id")
        motivo = mensaje
        try:
            conn = conectar_db()
            with conn.cursor() as cur:
                cur.execute("UPDATE pedidos SET estado = 'rechazado', motivo_rechazo = %s WHERE id = %s RETURNING usuario_id;", (motivo, pedido_id))
                resultado = cur.fetchone()
                conn.commit()
            if resultado:
                await context.bot.send_message(chat_id=resultado[0], text=f"‚ùå Tu pedido #{pedido_id} ha sido rechazado.\n*Motivo:* {motivo}")
            await update.message.reply_text(f"‚ùå Pedido #{pedido_id} rechazado y usuario notificado.")
        except Exception as e:
            print(f"Error al rechazar pedido {pedido_id}: {e}")
        finally:
            if 'conn' in locals() and conn: conn.close()
            context.user_data.clear()
        return

    estado_usuario = context.user_data.get("estado")
    if not estado_usuario: return

    if estado_usuario == "esperando_numero":
        if not (mensaje.isdigit() and len(mensaje) >= 8):
            await update.message.reply_text("‚ùå N√∫mero inv√°lido. Env√≠a solo d√≠gitos.")
            return
        context.user_data["numero"] = mensaje
        context.user_data["estado"] = "esperando_comprobante"
        try:
            conn = conectar_db()
            with conn.cursor() as cur:
                cur.execute("INSERT INTO pedidos (usuario_id, oferta_id, numero_destino) VALUES (%s, %s, %s) RETURNING id;", (user_id, context.user_data["oferta_id"], mensaje))
                pedido_id = cur.fetchone()[0]
                conn.commit()
            context.user_data["pedido_id"] = pedido_id
            await update.message.reply_text("üî¢ N√∫mero guardado.\n\nüí∏ Ahora env√≠a una captura del comprobante de pago.")
        except Exception as e:
            print(f"Error al guardar pedido: {e}")
        finally:
            if 'conn' in locals() and conn: conn.close()
            
    elif estado_usuario == "esperando_comprobante":
        # Manejar comprobantes de texto, aunque se esperan im√°genes
        await update.message.reply_text("Por favor, env√≠a el comprobante como una imagen, no como texto.")

# ------------------ Manejador de im√°genes ---------------------
async def recibir_imagen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Procesa im√°genes, las guarda como comprobante y notifica a los admins."""
    user_id = update.effective_user.id
    if context.user_data.get("estado") != "esperando_comprobante":
        return

    file_id = update.message.photo[-1].file_id
    try:
        conn = conectar_db()
        with conn.cursor() as cur:
            # Guardamos el comprobante en la base de datos
            cur.execute("INSERT INTO comprobantes (pedido_id, tipo, contenido) VALUES (%s, %s, %s);", (context.user_data["pedido_id"], "imagen", file_id))
            conn.commit()
        
        # Notificamos al usuario que todo sali√≥ bien
        await update.message.reply_text("‚úÖ ¬°Imagen recibida! Tu pedido ser√° validado por un administrador a la brevedad.")

        # --- INICIO: Bloque de Notificaci√≥n a Administradores ---
        try:
            pedido_id = context.user_data["pedido_id"]
            user_nombre = update.effective_user.full_name
            oferta_txt = context.user_data.get("oferta_txt", "Oferta no especificada")

            botones_notificacion = [[
                InlineKeyboardButton("üîç Ver y Gestionar Pedido Ahora", callback_data=f"ver_pedido_{pedido_id}")
            ]]
            markup = InlineKeyboardMarkup(botones_notificacion)

            mensaje_para_admin = (
                f"üîî *¬°Nueva Solicitud de Recarga Pendiente!* üîî\n\n"
                f"üë§ **De:** {user_nombre}\n"
                f"üéÅ **Oferta:** {oferta_txt}"
            )

            for admin_id in ADMIN_IDS:
                try:
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=mensaje_para_admin,
                        parse_mode="Markdown",
                        reply_markup=markup
                    )
                except Exception as e_inner:
                    print(f"Fallo al notificar al admin {admin_id}: {e_inner}")
        except Exception as e:
            print(f"Error cr√≠tico al intentar notificar a los admins: {e}")
        # --- FIN: Bloque de Notificaci√≥n a Administradores ---

    except Exception as e:
        print(f"Error al guardar imagen de comprobante: {e}")
        await update.message.reply_text("‚ùå Ocurri√≥ un error al guardar tu comprobante. Por favor, contacta a un administrador.")
    finally:
        # Limpiamos los datos del usuario al final de todo el proceso
        context.user_data.clear()
        if 'conn' in locals() and conn: conn.close()

# ------------------ Panel de Administraci√≥n (/admin) ---------------------
async def admin(update: Update, context: ContextTypes.DEFAULT_TYPE, is_callback=False):
    if not es_admin(update.effective_user.id):
        await update.message.reply_text("üö´ Acceso denegado.")
        return
    botones_admin = [[InlineKeyboardButton("üì• Ver Pedidos Pendientes", callback_data="admin_pedidos")]]
    texto = "üîê Panel de Administraci√≥n"
    reply_markup = InlineKeyboardMarkup(botones_admin)
    if is_callback:
        await update.callback_query.edit_message_text(text=texto, reply_markup=reply_markup)
    else:
        await update.message.reply_text(text=texto, reply_markup=reply_markup)

# ------------------ Iniciar Bot ---------------------
def main():
    app = ApplicationBuilder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin))
    app.add_handler(CallbackQueryHandler(manejar_callback_unificado))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, recibir_mensaje))
    app.add_handler(MessageHandler(filters.PHOTO, recibir_imagen))
    
    print("Bot iniciado...")
    app.run_polling()

if __name__ == "__main__":
    main()